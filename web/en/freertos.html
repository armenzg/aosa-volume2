<html>
  <head>
    <meta name="provenance" content="$Id$" />
    <link rel="stylesheet" href="aosa.css" type="text/css" />
    <title>The Architecture of Open Source Applications, Volume 2: FreeRTOS</title>
  </head>
  <body>

    <div class="header">
      <table>
	<tr>
	  <td>
	    <a href="index.html"><img src="../images/titlebar.jpg" alt="The Architecture of Open Source Applications, Volume 2" /></a>
	  </td>
	  <td>
	    <strong><em>The Architecture of Open Source Applications, Volume 2</em></strong>
	    <br/>
	    <strong>Amy Brown and Greg Wilson (eds.)</strong>
	  </td>
	</tr>
      </table>
      <h1 class="chaptitle">FreeRTOS</h1>
      <h1 class="chapterauthor"><a href="intro.html#svec-christopher">Christopher Svec</a></h1>
    </div>


<p>FreeRTOS is an open source real-time operating system (RTOS) for embedded systems.</p>

<p>FreeRTOS's web site<sup class="footnote"><a href="#footnote-1">1</a></sup> sums it 
up like this:</p>

<p>"FreeRTOS(tm) includes official ports to 27 architectures [and 17 toolchains] and 
receives more than 77,500 downloads a year. It is market leading, robust, supported, 
portable, open source, free to download, and free to deploy.  FreeRTOS can be used in 
commercial applications without any requirement to expose your proprietary source 
code. With a growing ecosystem, FreeRTOS is commonly integrated with both open source 
and commercial TCP/IP, file system, and USB components."</p>

<p>FreeRTOS has an active, free support forum on SourceForge.</p>

<p>Commercial (paid) FreeRTOS support is also available under the OpenRTOS and 
SafeRTOS brands, owned by WITTENSTEIN.<sup class="footnote"><a href=#footnote-2">2</a></sup></p>

<p>This chapter discusses FreeRTOS version 7.0.1, released on May 13, 2011.</p>

<p>FreeRTOS is under active development, and has been since Richard Barry started 
work on it in 2002. FreeRTOS 7.0.2 was released as this chapter was being written. It 
added new APIs, demo applications, as well as support for new chip architectures, but 
doesn't change any information that this chapter covers.</p>

<p>FreeRTOS is intended to be simple, small, and reliable. A typical binary code 
image is less than 10K.</p>

<p>As for me, I'm not a developer of or contributor to FreeRTOS (yet, anyway), 
I'm merely a user and a fan. As a result, this chapter will favor the "what" 
and "how" of FreeRTOS's architecture, with less of the "why" than other chapters in 
this book.</p>

<p>I assume that most people reading this are not embedded developers, and so 
I'm going to spend a nibble more time on "background" topics than other chapters in 
this book.</p>

<p>(A nibble is four bits, so it's a little more than a bit. And no, the jokes will 
not get any better.)</p>

<p>By the end of this chapter I hope that you'll understand the basic architecture of 
FreeRTOS. If this is your first look under the hood of an operating system, I also 
hope that you'll learn the basics about how any OS works. FreeRTOS is relatively 
simple, especially when compared to Windows, Linux, or OS X, but all operating 
systems share the basic concepts and goals, and so looking at any OS can be very 
instructive and interesting.</p>

<div class="sect">
<h2>999.1. And Now It's Time For a Breakdown</h2>

<p>Again, FreeRTOS is an open source real-time operating system (RTOS) for embedded 
systems. That blurb has at least three words in it that mean different things to 
different people, so let's break them down.</p>

<div class="subsect">
<h3>999.1.1. "Embedded"</h3>

<p>Let's start by defining "embedded system" by saying what it's not.</p>

<p>A general purpose computer system is designed to do pretty much whatever the user 
wants. Do you want to play a game? Or browse the web?  Or edit spreadsheets? Or play 
or compose music? Your desktop or laptop computer can do any of these, as well as 
about a zillion other things as well. Ditto for your iPad, your iPhone, and even your 
old Commodore 64.</p>

<p>These are not embedded systems.</p>

<p>Unlike general purpose systems, embedded systems are designed to do only a few 
things. </p>

<p>The TomTom GPS system in your car is a great example of an embedded system.  
It does only a couple of things: it knows where you are and it tells you how to 
get where you're going. You can't browse the web on it, you can't send email 
with it, and if you ever believe you're playing Grand Theft Auto on it you're 
probably in for some prison time.</p>

<p>Other examples of embedded systems are TV remote controls, digital watches, and 
pacemakers.</p>

<p>Embedded systems are typically smaller and slower than general purpose computer 
systems, and are frequently also less expensive.</p>

</div>

<div class="subsect">
<h3>999.1.2. "OS"</h3>

<p>"OS" stands for "operating system." An OS is software that lets you use the 
computer.  It manages the computer's hardware so that you don't have to worry about 
it. Linux, Microsoft Windows, and Mac OS X are three of the most popular examples of 
operating systems.</p>

<p>Many very simple embedded systems have no operating system. The software 
that runs on these embedded systems manages the hardware itself; that is usually a 
large part of its functionality.</p>

<p>For example, a simple digital wristwatch probably doesn't have an operating 
system.  The software that controls the watch updates the display by talking directly 
to the LCD hardware. It keeps track of the passage of time by handling the timer 
interrupts.  It lets the user set the alarm by watching for buttons presses.</p>

<p>For more complex devices with more functionality, hiding the underlying hardware 
from the software can make the software's job easier. An operating system sits on the 
top of the hardware, and handles the nuts and bolts of talking directly to the 
hardware.  The application software talks to the OS instead of the hardware, which is 
usually conceptually easier and cleaner.</p>

</div>

<div class="subsect">
<h3>999.1.3. "Real-Time"</h3>

<p>Real-time systems are designed to do something within a certain amount of
time.</p>

<p>Your home computer's operating system is probably not real-time. If the computer 
is busy and you start a new program, it may take many seconds or even minutes for the 
new program to start. There is no guarantee of response time.</p>

<p>Real-time systems guarantee that stuff happens when it's supposed to.</p>

<p>A pacemaker is an excellent example of a real-time embedded system. A pacemaker 
must contract the heart muscle at the right time to keep you alive. It can't be too 
busy to respond in time. Apple's spinning color wheel "waiting" indication is simply 
not an option, no matter how much you love your Mac. Pacemakers and other real-time 
embedded systems are carefully designed to run their tasks on time, every time.</p>

</div>

</div>

<div class="sect">
<h2>999.2. Architecture Overview</h2>

<div class="subsect">
<h3>999.2.1. FreeRTOS Organization</h3>

<p>FreeRTOS is a relatively small application. The minimum core of FreeRTOS is in 
three source (.c) files and a handful of header files, totalling just under 9000 
lines of code, including comments and blank lines.</p>

<div class="table" id="tbl.freertos.files">
  <table>
  <tr>
    <th>Filename</th><th>Number of Lines</th>
  </tr>
  <tr><td><code>FreeRTOS.h   </code></td><td> 468</td></tr>
  <tr><td><code>StackMacros.h</code></td><td> 174</td></tr>
  <tr><td><code>list.c       </code></td><td> 197</td></tr>
  <tr><td><code>list.h       </code></td><td> 314</td></tr>
  <tr><td><code>portable.h   </code></td><td> 396</td></tr>
  <tr><td><code>projdefs.h   </code></td><td>  83</td></tr>
  <tr><td><code>queue.c      </code></td><td>1539</td></tr>
  <tr><td><code>queue.h      </code></td><td>1270</td></tr>
  <tr><td><code>semphr.h     </code></td><td> 717</td></tr>
  <tr><td><code>tasks.c      </code></td><td>2522</td></tr>
  <tr><td><code>task.h       </code></td><td>1307</td></tr>
</table>
</div>

<div class="subsubsect">
<h4>999.2.1.1. Job Number One: Jobs. Err, Tasks.</h4>

<p>Most of FreeRTOS's code deals with the central figure in many operating systems: 
tasks.</p>

<p>Tasks, jobs, applications, call them what you like, but FreeRTOS calls them tasks, 
and FreeRTOS gets 'em done.</p>

<p><code>tasks.c</code> and <code>task.h</code> do all the heavy lifting for 
creating, scheduling, and maintaining tasks.</p>

</div>

<div class="subsubsect">
<h4>999.2.1.2. Job Number Two: I can't hear you... Communication!</h4>

<p>Tasks are good, but tasks that can communicate with each other are even better!  
Which brings us to the second largest FreeRTOS job: communication.</p>

<p>queue.c and queue.h handle most FreeRTOS communication. Tasks and interrupts use 
queues to send data to each other and to signal the use of critical resources using 
semaphores and mutexes.</p>

</div>

<div class="subsubsect">
<h4>999.2.1.3. Job Number Three: The Hardware Whisperer</h4>

<p>The ~9000 lines of code that make up the core of FreeRTOS are processor 
independent.  They don't talk directly to the hardware, they aren't aware of the 
underlying architecture at all.  The same code runs no matter what processor FreeRTOS 
is running on, from the humble 8051 to the largest-brand-spanking-newest ARM 
core.</p>

<p>If that processor independent FreeRTOS code doesn't talk to the hardware, then who 
does?  Why, the processor dependent FreeRTOS code, of course!</p>

<p>The processor independent FreeRTOS layer sits on top of a processor dependent 
layer.  This processor dependent layer knows how to talk to whatever chip 
architecture and compiler toolchain you choose.</p>

[IMAGE: insert obligatory pic of hw/hw-dep-freertos/hw-indep-freertos/tasks layers]

<p>FreeRTOS ships with all the processor independent as well as processor dependent 
code you'll need to get a system up and running. It supports many compilers 
(CodeWarrior, GCC, IAR, SDCC, etc.) as well as many processor architectures (ARM7, 
ARM Cortex-M3, various PICs, Silicon Labs 8051, x86, etc.). See the FreeRTOS website 
for all supported architectures and compilers.</p>

<p>This chapter will focus on the processor independent FreeRTOS core functionality.  
I won't be talking much about the processor dependent details since those will vary 
widely; each processor architecture could have its own chapter.</p>

</div>

</div>

<div class="subsect">
<h3>999.2.2. Platform Considerations</h3>

<p>FreeRTOS is highly configurable. It has to be since it runs on 27+ chip 
architectures, some of which are wildly different from each other.  FreeRTOS can be 
built as a single CPU, bare-bones, stripped down RTOS, supporting only a few tasks, 
or it can be built as a highly functional multicore beast with TCP/IP, a file system, 
and USB.</p>

<p>Configuration options are selected in <code>FreeRTOSConfig.h</code> by setting 
various <code>#defines</code>. Clock speed, heap size, mutexes, and API subsets are 
all configurable in this file, along with a ton of other options.</p>

<p>Many of FreeRTOS's functions are defined as C preprocessor macros using 
<code>#defines</code>.  For non-embedded applications this is a cardinal sin, but in 
many smaller embedded systems the overhead for calling a function is not worth the 
advantages that "real" functions offer.</p>

</div>

</div>

<div class="sect">
<h2>999.3. FreeRTOS Data Structures</h2>

<p>Now that we have the high level overview out of the way, let's dive in to the 
details.</p>

<p>In his book "The Mythical Man-Month," [<a 
  href="bibliography.html#bib:brooks:freertos">Bro95</a>] Fred Brooks famously says: 
"Show me your flowcharts and conceal your tables, and I shall continue to be 
mystified.  Show me your tables, and I won't usually need your flowcharts; they'll be 
obvious."</p>

<p>The modern-day equivalent of this quote is "Show me your data structures and I 
won't need your algorithms, they'll be obvious."</p>

<p>Fred Brooks knows what he's talking about, so let's start with the data 
structures.</p>

<p>We'll look at the three main FreeRTOS data structures: Tasks, Lists, and 
Queues.</p>

<div class="subsect">
<h3>999.3.1. Caveats</h3>

<p>Many of FreeRTOS's basic data types are processor dependent <code>typedefs</code> 
or <code>#defines</code>.  I've changed those <code>typedefs</code> and 
<code>#defines</code> to a common data type to make this chapter more readable.</p>

<p>For instance, the basic task priority level data type is 
<code>portBASE_TYPE</code>.  This type usually resolves to an <code>unsigned 
  short</code> or an <code>unsigned long</code> type, but I'm simply going to call it 
an <code>unsigned int</code>.  This gets the point across without getting bogged down 
in unfamiliar <code>portBASE_TYPE</code>, <code>portSTACK_TYPE</code>, and 
<code>portTickType</code> definitions, and also lets us ignore whether a type is a 
<code>short</code> or <code>long</code>. For our purposes it just doesn't matter.</p>

<p>Also, I'm going to omit some optional data structure members for clarity's 
sake.</p>

<p>You've been warned: Don't be surprised if the actual FreeRTOS code looks a bit 
different than what is shown here. The changes are aesthetic only, no content was 
harmed in the making of this chapter.</p>

</div>

<div class="subsect">
<h3>999.3.2. Tasks</h3>

<p>The main job of all operating systems is to run and coordinate user tasks.</p>

<p>Like many operating systems, the basic unit of work in FreeRTOS is "the task." 
</p>

<p>FreeRTOS uses a Task Control Block (TCB) to represent each task. The TCB is 
defined in tasks.c like this:</p>

<pre>
/*
 * Task control block.  A task control block (TCB) is allocated to each task,
 * and stores the context of the task.
 */
typedef struct tskTaskControlBlock
{
  volatile unsigned int *pxTopOfStack;                   /*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE STRUCT. */
                                                         
  xListItem    xGenericListItem;                         /*< List item used to place the TCB in ready and blocked queues. */
  xListItem    xEventListItem;                           /*< List item used to place the TCB in event lists.  */
  unsigned int uxPriority;                               /*< The priority of the task where 0 is the lowest priority. */
  unsigned int   *pxStack;                               /*< Points to the start of the stack. */
  signed char    pcTaskName[ configMAX_TASK_NAME_LEN ];  /*< Descriptive name given to the task when created.  Facilitates debugging only. */

  #if ( portSTACK_GROWTH > 0 )
    unsigned int *pxEndOfStack;                          /*< Used for stack overflow checking on architectures where the stack grows up from low memory. */
  #endif

  #if ( configUSE_MUTEXES == 1 )
    unsigned int uxBasePriority;                         /*< The priority last assigned to the task - used by the priority inheritance mechanism. */
  #endif

} tskTCB;
</pre>

<p>The TCB stores the address of the stack start address in <code>pxStack</code> and 
the current top of stack in <code>pxTopOfStack</code>. It also stores a pointer to 
the end of the stack in <code>pxEndOfStack</code> to check for stack overflow if the 
stack grows "up" to higher addresses. If the stack grows "down" to lower addresses 
then stack overflow is checked by comparing the current top of stack against the 
start of stack memory in <code>pxStack</code>.</p>

<p>The TCB stores the initial priority of the task in <code>uxPriority</code> and 
<code>uxBasePriority</code>. A task is given a priority when it is created. Higher 
priority tasks will be given priority over lower priority tasks. A task's priority 
can be changed.  If FreeRTOS implements priority inheritance then it uses 
<code>uxBasePriority</code> to remember the original priority while the task is 
temporarily elevated to the "inherited" priority. (See the discussion about mutexes 
below for more on priority inheritance.)</p>

<p>0 is the lowest priority. The highest priority is user-configurable at compile 
time.  The scheduler allocates a ready list for each priority level, so use as few 
priority levels as possible to reduce memory usage.</p>

<p>Each task has two list items for use in FreeRTOS's various scheduling lists. The 
<code>xGenericListItem</code> and <code>xEventListItem</code> live for the lifetime 
of the task and are inserted into and remove from lists as the task carries out its 
work.</p>

<p>Interestingly, the TCB structure doesn't have a field that keeps track of the 
state of the task.</p>

<p>A task can be in one of four states: running, ready to run, suspended, or blocked.  
You might expect each task to have a variable that tells FreeRTOS what the task is 
doing. Instead, however, FreeRTOS tracks task state implicitly by putting tasks in 
the appropriate list: ready list, suspended list, etc.</p>

<p>As a task changes from one state to another, FreeRTOS simply moves it from one 
list to another, without needing to explicitly maintain a state variable.</p>

</div>

<div class="subsect">
<h3>999.3.3. Lists</h3>

<p>FreeRTOS uses a list structure to keep track of tasks for scheduling, and also to 
implement its queues.</p>

<p>The FreeRTOS list is a standard circular doubly linked list with a couple of 
interesting additions. Here's a list element:</p>

<pre>
struct xLIST_ITEM
{
  unsigned int xItemValue;                  /*< The value being listed.  In most cases this is used to sort the list in descending order. */
  volatile struct xLIST_ITEM * pxNext;      /*< Pointer to the next xListItem in the list.  */
  volatile struct xLIST_ITEM * pxPrevious;  /*< Pointer to the previous xListItem in the list. */
  void * pvOwner;                           /*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
  void * pvContainer;                      /*< Pointer to the list in which this list item is placed (if any). */
};
</pre>

<p>Each list element holds a number, <code>xItemValue</code>, that is the priority of 
the task being tracked.</p>

<p>Lists are kept in high-to-low priorty order, meaning that the highest priority 
xItemValue (the largest number) is at the front of the list and the lowest priority 
xItemValue (the smallest number) is at the end of the list.</p>

<p>The <code>pxNext</code> and <code>pxPrevious</code> pointers are standard list 
pointers.</p>

<p><code>pvOwner</code> is a pointer to the owner of the list element. This is 
usually a task's TCB object. <code>pvOwner</code> allows a list walking function to 
quickly get to the task who's priority this list element is for.</p>

<p><code>pvContainer</code> points to the list that this item is in. It is used to 
quickly determine if a list item is in a particular list.</p>

<p>Each list element can be put in a list, which is defined as:</p>

<pre>
typedef struct xLIST
{
  volatile unsigned int uxNumberOfItems;
  volatile xListItem * pxIndex;          /*< Used to walk through the list.  Points to the last item returned by a call to pvListGetOwnerOfNextEntry (). */
  volatile xMiniListItem xListEnd;       /*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
} xList;
</pre>

<p>The size of a list at any time is stored in <code>uxNumberOfItems</code> for fast 
list size operations.</p>

<p>Most "traditional" list accesses you've ever used probably do all of their work 
within a single for() loop or function call like this:</p>

<pre>
for (listPtr = listStart; listPtr != NULL; listPtr = listPtr->next) {
  // Do something with listPtr here...
}
</pre>

<p>FreeRTOS frequently needs to access a list across multiple for() and while() 
loops, and so it uses list functions that manipulate the <code>pxIndex</code> pointer 
to walk the list. The list function <code>listGET_OWNER_OF_NEXT_ENTRY</code> 
(actually a macro), does <code>pxIndex = pxIndex->pxNext;</code> and returns 
<code>pxIndex</code>. (Of course it does the proper wraparound detection too.) This 
way the list itself is responsible for keeping track of "where you are" while walking 
it using <code>pxIndex</code>, allowing the rest of FreeRTOS to not worry about 
it.</p>

<p>All new lists contain a single element: the <code>xListEnd</code> element.  
<code>xListEnd</code> contains the maximum priority value.</p>
 
<p>Since lists are sorted high-to-low, the <code>xListEnd</code> element is used as a 
marker for the start of the list.  And since the list is circular, this 
<code>xListEnd</code> element is also a marker for the end of the list.</p>

<p>The scheduler has an array of lists, one list for each priority level:</p>

<pre>
static xList pxReadyTasksLists[ configMAX_PRIORITIES ]; /*< Prioritised ready tasks.  */
</pre>

<p>The scheduler also has a variety of other lists that are used for tasks that are 
not in the ready state (suspended, etc.).</p>

</div>

<div class="subsect">
<h3>999.3.4. Queues</h3>

<p>FreeRTOS allows tasks and ISRs to communicate and synchronize with each other 
using queues.</p>

<p>The basic queue data structure is:</p>

<pre>
/*
 * Definition of the queue used by the scheduler.
 * Items are queued by copy, not reference.
 */
typedef struct QueueDefinition
{
  signed char *pcHead;                     /*< Points to the beginning of the queue storage area. */
  signed char *pcTail;                     /*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
                                           
  signed char *pcWriteTo;                  /*< Points to the free next place in the storage area. */
  signed char *pcReadFrom;                 /*< Points to the last place that a queued item was read from. */
                                           
  xList xTasksWaitingToSend;               /*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
  xList xTasksWaitingToReceive;            /*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */

  volatile unsigned int uxMessagesWaiting; /*< The number of items currently in the queue. */
  unsigned int uxLength;                   /*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
  unsigned int uxItemSize;                 /*< The size of each items that the queue will hold. */
                                         
  signed int xRxLock;                      /*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
  signed int xTxLock;                      /*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
} xQUEUE;
</pre>

<p>This is a fairly standard queue with head and tail pointers, as well as pointers 
to keep track of where we've just read from and written to.</p>

<p>When creating a queue the user specifies the length of the queue and the size of 
each element in the queue. Adding an item into a queue does a deep copy of the item 
into the queue's internal memory.</p>

<p>FreeRTOS supports blocking and non-blocking queue insertions and removals.</p>

<p>Non-blocking operations return immediately with a "did the queue insert work?" or 
"did
the queue remove work?" status.</p>

<p>Blocking operations are specified with a timeout. A task can block indefinitely or 
for a
given amount of time.</p>

<p>In the "block indefinitely" case an insert operation blocks until there is space 
in the
queue, and a remove operation blocks until there is at least one item in the queue. The
insert/remove operation then returns with a "passed" status.</p>

<p>The "block for a given amount of time" case is similar, except that if an 
insert/remove operation isn't possible within the given amount of time the 
insert/remove returns with a "failed" status.</p>

<p>FreeRTOS uses the <code>xTasksWaitingToSend</code> list to keep track of tasks 
that are
blocking on inserting into the queue. Similarly, <code>xTasksWaitingToReceive</code>
keeps track of tasks that are blocking on removing from the queue.</p>

<p>The <code>xRxLock</code> and <code>xTxLock</code> elements are used for - you 
guessed it - locking a queue.  We'll look at those when we discuss the queueing 
algorithms later.</p>

</div>

<div class="subsect">
<h3>999.3.5. Semaphores and Mutexes</h3>

<div class="subsubsect">
<h4>999.3.5.1. What's The Difference?</h4>

<p>Semaphores and mutexes may sound like the same thing, but they're not. FreeRTOS 
implements them similarly, but they're intended to be used in different ways.</p>

<p>How should they be used differently? Embedded guru Michael Barr says it best here 
in his article, "Mutexes and Semaphores Demystified":<sup class="footnote"><a href="#footnote-3">3</a></sup></p>

<p>"The correct use of a semaphore is for signaling from one task to another. A mutex 
is meant to be taken and released, always in that order, by each task that uses the 
shared resource it protects. By contrast, tasks that use semaphores either signal 
["send" in FreeRTOS terms] or wait ["receive" in FreeRTOS terms] - not both."</p>

<p>If you're at all in doubt about semaphores and mutexes please check out Michael's 
article.</p>

</div>

<div class="subsubsect">
<h4>999.3.5.2. Implementation</h4>

<p>FreeRTOS implements a binary semaphore as a one item queue. It doesn't store any 
actual data in the queue, it just cares if the queue is empty or full: it's doing 
"pure synchronization" as the FreeRTOS header file <code>semphr.h</code> calls it.  
Therefore the queue has a data size of zero bytes (<code>uxItemSize == 0</code>).</p>

<p>The binary semaphore is given and taken using short macros that call the normal 
queue functions.</p>

<p>A counting semaphore of length N is also accessed with thin give and take macros 
wrapped around the normal queue functions, but is implemented as an N-element queue.  
As with a binary semaphore, a counting semaphore's queue has a data size of zero 
bytes.</p>

<p>A mutex is also implemented as a queue, but several of the <code>xQUEUE</code> 
struct fields are overloaded using <code>#defines</code>:</p>

<pre>
/* Effectively make a union out of the xQUEUE structure. */
#define pxMutexHolder         pcTail
#define uxQueueType           pcHead
#define uxRecursiveCallCount  pcReadFrom
#define queueQUEUE_IS_MUTEX   NULL
</pre>

<p>For the most part FreeRTOS uses the same queue code to handle semaphores and 
mutexes.</p>

<p>The difference is that mutexes implement priority inheritance, whereas semaphores 
don't.</p>

<p>In case you're not familiar with priority inheritance, I'll quote Michael Barr 
again to define it, this time from his article, "Introduction to Priority 
Inversion":<sup class="footnote"><a href="#footnote-4">4</a></sup></p>


<p>"[Priority inheritance] mandates that a lower-priority task inherit the priority 
of any higher-priority task pending on a resource they share. This priority change 
should take place as soon as the high-priority task begins to pend; it should end 
when the resource is released."</p>

<p>FreeRTOS implements priority inheritance using the <code>pxMutexHolder</code> 
field (which is really just the overloaded-by-<code>#define</code> 
<code>pcTail</code> field).  When a higher priority task is found to be waiting on a 
mutex currently taken by a lower priority task, FreeRTOS "upgrades" the lower 
priority task to the priority of the higher priority task until the mutex is 
available again.</p>
</div>

</div>

</div>

<div class="sect">
<h2>999.4. Algorithms</h2>

<p>Even though I paraphrased Fred Brooks as saying "Show me your data structures and 
I won't need your algorithms, they'll be obvious," it's still valuable to consider 
the algorithms FreeRTOS uses for tasks and queues.</p>

<div class="subsect">
<h3>999.4.1. Task setup</h3>
    
<p>A task is created when the user calls <code>xTaskCreate()</code>.</p>

<p>FreeRTOS uses a newly allocated TCB object to store the name, priority, and other 
details for a task.</p>

<p>FreeRTOS allocates the amount of stack the user requests (assuming there's enough 
memory available) and remembers the start of the stack memory in TCB's 
<code>pxStack</code> member.</p>

<p>The stack is initialized to look as if the new task is already running and was 
interrupted by a context switch. This way the scheduler can treat newly created tasks 
exactly the same way as tasks that have already been running for a while; the 
scheduler doesn't need any special case code for handling new tasks.</p>

<p>The exact way that a task's stack is made to look like it was interrupted by a 
context switch depends on the architecture FreeRTOS is running on, but this ARM 
Cortex-M3 processor's implementation is a good example:</p>

[IMAGE: insert graphic here, based on this code]
<pre>
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE 
pxCode, void *pvParameters )
{
  /* Simulate the stack frame as it would be created by a context switch
  interrupt. */
  pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
  *pxTopOfStack = portINITIAL_XPSR;  /* xPSR */
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) pxCode;  /* PC */
  pxTopOfStack--;
  *pxTopOfStack = 0;  /* LR */
  pxTopOfStack -= 5;  /* R12, R3, R2 and R1. */
  *pxTopOfStack = ( portSTACK_TYPE ) pvParameters;  /* R0 */
  pxTopOfStack -= 8;  /* R11, R10, R9, R8, R7, R6, R5 and R4. */
  
  return pxTopOfStack;
}
</pre>
[That code won't actually be in the doc, the image will have all the info I want to 
convey.]

<p>After the stack is prepared, the task is almost ready to run.</p>

<p>First though, FreeRTOS disables interrupts: We're about to start mucking with the 
ready lists and other scheduler structures and we don't want anyone else changing 
them underneath us.</p>

<p>If this is the first task to ever be created, FreeRTOS initializes the scheduler's 
task lists. FreeRTOS's scheduler has an array of ready lists, 
<code>pxReadyTasksLists[]</code>, which has one ready list for each possible priority 
level. FreeRTOS also has a few other lists for tracking tasks that have been 
suspended, killed, and delayed. These are all initialized now as well.</p>

<p>After any first-time initialization is done the new task is added to the ready 
list at its specified priority level.</p>

<p>Interrupts are reenabled and new task creation is complete.</p>

</div>

<div class="subsect">
<h3>999.4.2. Scheduler and the System Tick</h3>

<p>The heartbeat of a FreeRTOS system is called the tick. FreeRTOS configures the 
system to generate a periodic tick interrupt. The user can configure the tick 
interrupt frequency, which is typically in the millisecond range.</p>

<p>Every time the tick interrupt fires the <code>vTaskSwitchContext()</code> function 
is called. <code>vTaskSwitchContext()</code> makes sure the highest priority task is 
running like this:</p>

<pre>
/* Find the highest priority queue that contains ready tasks. */
while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
{
    configASSERT( uxTopReadyPriority );
    --uxTopReadyPriority;
}

/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the same priority get an equal share of the processor time. */
listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
</pre>

<p>It's as easy as a quick list traversal to find the highest priority level with 
ready tasks, and then grabbing the first ready task from that priority level's ready 
list.</p>

<p>Now <code>pxCurrentTCB</code> points to the highest priority task, and when 
<code>vTaskSwitchContext()</code> returns the processor dependent code starts running 
that task.</p>

<p>Those nine lines of code are the absolute crux of FreeRTOS. The rest of FreeRTOS 
(the other ~8991 lines) is there to make sure those nine lines are all that's needed 
to keep the highest priority task running.</p>

</div>

<div class="subsect">
<h3>999.4.3. Queue Accesses</h3>

<p>Since FreeRTOS uses queues as often as graphic designers use Apple comparisons, 
let's take a look at the queue access algorithms.</p>

<p>The queue insertion and removal algorithms are very similar, and so I'm only going 
to describe queue insertion as implemented in <code>xQueueGenericSend()</code>.  
Please check out the removal implementation in queue.c if you'd like to know how it's 
implemented.</p>

<p>Let's start by looking at a task, which I'll creatively call "Task A," inserting a 
new element into a queue. FreeRTOS uses the word "send" for inserting an item into a 
queue and "receive" for removing an item from a queue, but we'll use the more 
commonly used "insert" and "remove" here. (Using "send" and "receive" does make sense 
for FreeRTOS because it emphasizes that FreeRTOS uses queues for communication
between tasks.)</p>

<p>A word of warning: If the goto statement is considered harmful in code, then it 
must be considered downright evil in prose, but I'm going to use it anyway.</p>

<p>The queue insert function is basically a big infinite <code>for()</code> loop that 
keeps looping until the queue insert succeeds or times out.</p>

<p>Later in this discussion I'm going to say that the queue code executes a "goto 
top".  That "goto" jumps here in the prose.</p>

<p>The first thing FreeRTOS does when accessing a queue is disables (most) 
interrupts, which causes context switches to also be disabled. If it didn't, another 
task or interrupt service routine could be switched in while Task A was in the middle 
of updating the queue's data structure, and you're hosed.</p>

<p>Next FreeRTOS checks if the queue has space for the new element. </p>

<div class="subsubsect">
<h4>999.4.3.1. If the queue has room for a new element:</h4>

<p>Then the new element is deep-copied into the queue and the queue size is updated.
Now FreeRTOS checks for any tasks waiting for data to arrive in the queue using the 
<code>xTasksWaitingToReceive</code> list.</p>

<p>If no task is waiting on data then FreeRTOS reenables interrupts and returns.  
Queue insertion is done.</p>

<p>If any tasks are waiting on data in the queue then FreeRTOS grabs the highest 
priority task from <code>xTasksWaitingToReceive</code>. We'll call it "Task B." If 
the currently running Task A is higher priority than Task B then FreeRTOS reenables 
interrupts and returns. Queue insertion is done.</p>

<p>If Task B is a higher priority than currently running Task A then Task A yields so 
that Task B is scheduled next. FreeRTOS reenables interrupts and returns. Queue 
insertion is done.</p>

</div>

<div class="subsubsect">
<h4>999.4.3.2. If the queue is full and does not have room for a new element:</h4>

<p>If Task A specified non-blocking queue insertion then we reenable interrupts and 
return. Queue insertion is done: the queue insertion failed.</p>

<p>If Task A specified blocking queue insertion then things get more interesting.</p>

<p>Let's review: if we "get here" in the algorithm the queue is full and Task A wants 
a blocking insertion.</p>

<p>Let's continue: FreeRTOS reenables interrupts but immediately disables the 
scheduler.  Now ISRs can fire so high priority real-time events can be handled, but 
no task switching can happen. The queue is now locked, which sets the 
<code>xRxLock</code> and <code>xTxLock</code> fields.</p>

<p>If the blocking timeout has expired then we unlock this queue, reenable the 
scheduler, then we "goto top." (Again, the code doesn't actually use a goto 
statement, it uses a for loop, but hey, this is prose, not code.)</p>

<p>If the blocking timeout hasn't expired then we check if the queue is still full.  
If it is still full, then we put Task A on the <code>xTasksWaitingToSend</code> list 
for this queue, unlock the queue, reenable the scheduler, and "goto top."</p>

<p>If the queue isn't full then we unlock the queue, reenable the scheduler, and
"goto top."</p>

</div>


<p>Note that Task A stays in <code>xQueueGenericSend()</code>'s infinite 
<code>for()</code> loop until the insert succeeds or the timeout expires. Other tasks 
may run during times when <code>xQueueGenericSend()</code> has left interrupts and 
task switching enabled.</p>

</div>

</div>

<div class="sect">
<h2>999.5. Conclusion</h2>

<p>We've completed our look at the FreeRTOS's main data structures and algorithms.</p>

<p>Hopefully you have a good feel for how FreeRTOS tasks run and communicate. And if 
you've never looked at any OS's internals before you now have a basic idea of how 
they work.</p>

<p>Obviously this chapter did not cover all of FreeRTOS's architecture. Notably, I 
didn't mention memory allocation, ISRs, debugging, or MPU support. Please check out 
the source code for more information about the FreeRTOS architecture.</p>

<p>This chapter also did not discuss how to setup or use FreeRTOS. Richard Barry has 
written an excellent book<sup class="footnote"><a href="#footnote-5">5</a></sup>, 
"Using the FreeRTOS Real Time Kernel - a Practical Guide," which discusses exactly 
that.  It's not free, but it's authoritative and very well written; I highly 
recommend it if you're going to use FreeRTOS.</p>

[Amy/Greg: I'm not sure if I should use a footnote or a bibliography reference there: 
it's a book *and* a URL.]

</div>

<div class="sect">
<h2>999.6. Acknowledgements</h2>

<p>I would like to thank Richard Barry for creating and maintaining FreeRTOS, and for 
choosing to make it open source. Richard was very helpful in writing this chapter, 
providing some FreeRTOS history as well as technical review.</p>

<p>Thanks also to Amy Brown and Greg Wilson for pulling this whole AOSA thing
together.</p>

<p>Last and most (the opposite of "not least"), thanks to my wife Sarah for
sharing me with the research and writing for this chapter. Luckily she knew I
was a geek when she married me!</p>

</div>

<div class="footnotes">
<h2>Footnotes</h2>
<ol>
<li id="footnote-1"<code class="url">http://www.freertos.org</code</li>
<li id="footnote-2"<code class="url">http://www.wittenstein-us.com/Embedded-RTOS.html</code></li>
<li id="footnote-3"<code class="url">http://www.netrino.com/node/202</code></li>
<li id="footnote-4"<code class="url">http://www.eetimes.com/discussion/beginner-s-corner/4023947/Introduction-to-Priority-Inversion</code></li>
<li id="footnote-5"<code class="url">http://www.freertos.org/Documentation/FreeRTOS-documentation-and-book.html</code</li>
</ol>
</div>

<div class="footer">

</div>

  </body>
</html>
